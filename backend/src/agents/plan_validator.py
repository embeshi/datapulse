import logging
import re
from typing import Dict, Tuple, Optional
from src.llm import client, prompts

logger = logging.getLogger(__name__)

def run_plan_validator(user_request: str, initial_plan: str, database_context: str) -> Tuple[str, bool, Optional[str]]:
    """
    Validates and potentially refines the initial plan generated by the planner.
    
    Args:
        user_request: The user's original natural language request
        initial_plan: The initial plan generated by the planner agent
        database_context: String containing schema and data summaries
        
    Returns:
        Tuple containing:
        - The final plan (original or revised)
        - A boolean indicating if the plan is feasible (True) or not (False)
        - An optional explanation string if the plan is infeasible
    """
    logger.info(f"Running plan validation for request: '{user_request[:50]}...'")
    
    try:
        # Generate and send the validation prompt to the LLM
        prompt = prompts.get_plan_validation_prompt(user_request, initial_plan, database_context)
        validation_response = client.call_llm(prompt)
        
        # Parse the response to extract the assessment, explanation, and revised plan
        assessment_match = re.search(r'ASSESSMENT:\s*(FEASIBLE|NEEDS REVISION|INFEASIBLE)', validation_response, re.IGNORECASE)
        explanation_match = re.search(r'EXPLANATION:\s*(.*?)(?:REVISED PLAN:|$)', validation_response, re.DOTALL | re.IGNORECASE)
        plan_match = re.search(r'REVISED PLAN:\s*(.*)', validation_response, re.DOTALL | re.IGNORECASE)
        
        # Extract the assessment result
        if assessment_match:
            assessment = assessment_match.group(1).strip().upper()
        else:
            logger.warning("Could not extract clear assessment from validator response")
            assessment = "FEASIBLE"  # Default to feasible if we can't parse
        
        # Extract the explanation
        explanation = explanation_match.group(1).strip() if explanation_match else "No explanation provided"
        
        # Extract the revised plan or use the original
        revised_plan = plan_match.group(1).strip() if plan_match else initial_plan
        
        # Log the validation results
        logger.info(f"Plan validation result: {assessment}")
        if assessment != "FEASIBLE":
            logger.info(f"Validation explanation: {explanation[:100]}...")
        
        if assessment == "INFEASIBLE":
            logger.warning("Plan deemed INFEASIBLE by validator")
            return revised_plan, False, explanation
        
        # For both FEASIBLE and NEEDS REVISION, we return the plan (original or revised)
        if assessment == "NEEDS REVISION":
            logger.info("Plan needed revision - using validator's revised plan")
        else:
            logger.info("Plan validated as feasible")
            
        return revised_plan, True, None
        
    except Exception as e:
        logger.error(f"Plan validator failed: {e}")
        # If validation fails, return the original plan but mark as feasible
        # This ensures the workflow can continue even if validation has issues
        return initial_plan, True, None
